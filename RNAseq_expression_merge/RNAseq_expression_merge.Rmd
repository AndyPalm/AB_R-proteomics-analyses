---
title: "RNAseq_expresion_merge"
output: html_document
date: "2026-01-16"
---

```{r}
# --- 1. LIBRARIES ---
library(MASS, exclude = "select")
library(tidyverse) 
library(arrow)
library(readxl)
library(janitor)
library(ggrepel)
library(ggbeeswarm)
library(ggpubr)
library(pbapply)

# --- 2. GLOBAL PATHS & CONSTANTS ---
box_root <- "C:/Users/andbp/Box/Backus_Lab/Andrew_Becker/ABecker_Lab_Notebook/R_WD"
ref_dir  <- file.path(box_root, "Reference_dbs")
exp_dir  <- file.path(box_root, "AP2-327_HAEC-expression")
pq_dir   <- file.path(exp_dir, "02_R_Intermediates")
output_dir  <- file.path(box_root, "POCA2", "03_graphs_plots")

if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
```


```{r}
cond1 <- "DF" # Experimental (UP)
cond2 <- "UF" # Control (DOWN)

# Colors
c1_color <- "#E41A1C" # Red
c2_color <- "#377EB8" # Blue
c_grey   <- "grey80"

# Thresholds
LOD_THRESH <- 0.1
REG_THRESH <- 0.5
DISC_SIGMA <- 3

#Protein/gene labels
plot_labels <- c("WWC2","ICAM1","LIPH","LIPA","PIEZO1","NOS3","GPC1","IGTB1","ITGA1","ADAM10","NOTCH1","SDC4","SDC1","CDH5","CDH1","BMPR1A","YAP1","BST2","IGSF8","ANGPT2","OSBPL8","VWF","BMX","STK38","CYRIA","DNMT1","ENG","HMOX1","FLT1","NRP2","HPSE","BACH2","GLI2","GPIHBP1","ADAM12","ADAM17","ROBO4","FGB","S100A9","DAB2IP","PGF","FLI1","LEFTY2","APLNR")
```

```{r}
# --- HELPER FUNCTION: CSV to Parquet ---
load_or_convert <- function(csv_path, pq_path) {
  if (!file.exists(pq_path)) {
    message("Converting: ", basename(csv_path))
    temp <- arrow::read_csv_arrow(csv_path)
    arrow::write_parquet(temp, pq_path)
    return(temp)
  } else {
    message("Loading cached: ", basename(pq_path))
    return(arrow::read_parquet(pq_path))
  }
}

# Load Labels
df.labels <- read_excel(file.path(ref_dir, "uniprot_hs_genes_PTM-DBs_17jan26.xlsx"))

# Load RNA
rna_pq <- file.path(pq_dir, "SGH-JJM_RNAseq_UF-vs-DF.parquet")
exp.rna_input <- load_or_convert(file.path(exp_dir, "SGH-JJM_RNAseq_UF-vs-DF.csv"), rna_pq)

# Load Protein
prot_pq <- file.path(pq_dir, "327-top4-features_protein-level-data_impute.parquet")
exp.protein_input <- load_or_convert(
  file.path(exp_dir, "01_Input_Search_Results", "327-normalized_top4-features_protein-level-data_impute.csv"), 
  prot_pq
)
colnames(exp.protein_input)[colnames(exp.protein_input) == ""] <- "RowID"
```

```{r}
# --- RNA PROCESSING ---
# 1. Pivot Long
exp.rna_long <- exp.rna_input %>%
  pivot_longer(cols = -Gene, names_to = "Sample", values_to = "Expression") %>%
  mutate(Condition = ifelse(grepl(cond1, Sample), cond1, cond2)) %>%
  filter(Expression > 0) %>% 
  mutate(LogExpression = log2(Expression))

# 2. Calculate Stats & Categorize (Robust Logic)
stats.rna.clean <- exp.rna_long %>%
  group_by(Gene) %>%
  summarise(
    Mean_cond1 = mean(Expression[Condition == cond1], na.rm = TRUE),
    Mean_cond2 = mean(Expression[Condition == cond2], na.rm = TRUE),
    
    # Logic Counts
    n_Reg_Cond1 = sum(Expression[Condition == cond1] > REG_THRESH, na.rm = TRUE),
    n_Reg_Cond2 = sum(Expression[Condition == cond2] > REG_THRESH, na.rm = TRUE),
    n_Det_Cond1 = sum(Expression[Condition == cond1] > LOD_THRESH, na.rm = TRUE),
    n_Det_Cond2 = sum(Expression[Condition == cond2] > LOD_THRESH, na.rm = TRUE),
    
    # Stats
    RNA_Log2FC = mean(LogExpression[Condition == cond1], na.rm = TRUE) - 
                 mean(LogExpression[Condition == cond2], na.rm = TRUE),
    P_Value = t.test(LogExpression ~ Condition)$p.value,
    .groups = 'drop'
  ) %>%
  mutate(
    Adj_P_Value = p.adjust(P_Value, method = "BH"),
    
    # Classification
    Gaussian = if_else(n_Reg_Cond1 >= 2 & n_Reg_Cond2 >= 2, TRUE, FALSE),
    Flag_Binary_Cond1 = (n_Det_Cond1 >= 2 & n_Det_Cond2 == 0),
    Flag_Binary_Cond2 = (n_Det_Cond1 == 0 & n_Det_Cond2 >= 2),
    
    Category = case_when(
      Gaussian ~ "Quantitative",
      Flag_Binary_Cond1 ~ paste("Only in", cond1),
      Flag_Binary_Cond2 ~ paste("Only in", cond2),
      TRUE ~ "Noise"
    )
  ) %>%
  filter(Category != "Noise") # Filter immediately

# QC Plot
stats.rna.clean %>%
  filter(Category == "Quantitative") %>%
  ggplot(aes(x = RNA_Log2FC)) +
  geom_histogram(binwidth = 0.2, fill = "#a6bddb", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "RNA Distribution (Quantitative)", subtitle = paste0(cond1, " vs ", cond2))
```
PROTEIN PROCESSING
```{r}
# 1. Condition Tagging
prot_data <- exp.protein_input %>%
  mutate(Condition = ifelse(grepl(cond1, GROUP), cond1, cond2))

# 2. Counts per group
prot_counts <- prot_data %>%
  group_by(Protein) %>%
  summarise(
    n_cond1 = sum(Condition == cond1),
    n_cond2 = sum(Condition == cond2),
    .groups = 'drop'
  )

# 3. Quantitative Stats (T-Test)
valid_prots <- prot_counts %>% filter(n_cond1 >= 2 & n_cond2 >= 2) %>% pull(Protein)

stats.protein.clean <- prot_data %>%
  filter(Protein %in% valid_prots) %>%
  group_by(Protein) %>%
  summarise(
    Protein_Log2FC = mean(LogIntensities[Condition == cond1], na.rm = TRUE) - 
                     mean(LogIntensities[Condition == cond2], na.rm = TRUE),
    P_Value = t.test(LogIntensities ~ Condition)$p.value,
    .groups = 'drop'
  ) %>%
  mutate(Adj_P_Value = p.adjust(P_Value, method = "BH")) %>%
  # Annotation Join
  left_join(df.labels %>% select(Entry, `Gene Names (primary)`), by = c("Protein" = "Entry")) %>%
  filter(!is.na(`Gene Names (primary)`))

# 4. Exclusive Lists (for Singletons)
list_only_c1 <- prot_counts %>% filter(n_cond1 >= 2 & n_cond2 < 2) %>% pull(Protein)
list_only_c2 <- prot_counts %>% filter(n_cond2 >= 2 & n_cond1 < 2) %>% pull(Protein)

protein_only_cond1 <- prot_data %>% filter(Protein %in% list_only_c1)
protein_only_cond2 <- prot_data %>% filter(Protein %in% list_only_c2)

print(paste("Quantitative Proteins:", nrow(stats.protein.clean)))
```

TIERED MERGE
```{r}
# Prepare Protein Data with Full Gene Names for synonym rescue
stats.prot.enriched <- stats.protein.clean %>%
  left_join(df.labels %>% select(Entry, `Gene Names`), by = c("Protein" = "Entry"))

# Tier 1: Primary Match
match_tier1 <- stats.prot.enriched %>%
  inner_join(stats.rna.clean, by = c("Gene Names (primary)" = "Gene")) %>%
  mutate(Match_Type = "Primary")

# Tier 2: Synonym Rescue
orphans <- stats.prot.enriched %>%
  anti_join(stats.rna.clean, by = c("Gene Names (primary)" = "Gene"))

match_tier2 <- orphans %>%
  separate_rows(`Gene Names`, sep = "[;\\s]+") %>%
  inner_join(stats.rna.clean, by = c("Gene Names" = "Gene")) %>%
  group_by(Protein) %>%
  arrange(desc(abs(RNA_Log2FC))) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(Match_Type = "Synonym Rescue")

# Combine & Discordance Calc
proteogenomics <- bind_rows(match_tier1, match_tier2)

# Robust Linear Model
model_robust <- rlm(Protein_Log2FC ~ RNA_Log2FC, data = proteogenomics, psi = psi.bisquare)

proteogenomics_stats <- proteogenomics %>%
  mutate(
    Studentized_Resid = residuals(model_robust) / model_robust$s,
    Is_Discordant = abs(Studentized_Resid) > DISC_SIGMA,
    Z_Protein = as.numeric(scale(Protein_Log2FC)),
    Z_RNA = as.numeric(scale(RNA_Log2FC))
  )

print(paste("Total Pairs:", nrow(proteogenomics_stats)))
```

STUDENTIZWED RESIDUALS ANALYSIS (ROBUST LINEAR MODEL) AND VISUALIZATION
M-weighting model reduces influence of outliers on fitted linear model. Useful for heteroscedastic datasets (where variance is not constant across all values - e.g., the variance is much higher for low-abundance transcripts)
```{r}
plot_df <- proteogenomics_stats %>%
  mutate(Color_Resid = case_when(
    !Is_Discordant ~ "Concordant",
    Protein_Log2FC > 0 ~ paste("High in", cond1),
    TRUE ~ paste("High in", cond2)
  ))

reg_int <- coef(model_robust)[1]
reg_slope <- coef(model_robust)[2]
reg_sigma <- summary(model_robust)$sigma

my_colors <- setNames(c(c_grey, c1_color, c2_color), 
                      c("Concordant", paste("High in", cond1), paste("High in", cond2)))

reg_slope <- coef(model_robust)[2]
reg_int   <- coef(model_robust)[1]

eq_label <- paste0(
  "y = ", round(reg_slope, 2), "x ", 
  ifelse(reg_int >= 0, "+ ", "- "), 
  abs(round(reg_int, 2))
)

ggplot(plot_df, aes(x = RNA_Log2FC, y = Protein_Log2FC)) +
  # 1. Base Points
  geom_point(aes(color = Color_Resid), alpha = 0.7) +
  
  # 2. Regression Lines
  geom_abline(slope = reg_slope, intercept = reg_int) +
  geom_abline(slope = reg_slope, intercept = reg_int + (DISC_SIGMA * reg_sigma), linetype = 2) +
  geom_abline(slope = reg_slope, intercept = reg_int - (DISC_SIGMA * reg_sigma), linetype = 2) +
  
  # 3. OVERLAY: Black Circles for 'plot_labels'
  geom_point(data = subset(plot_df, `Gene Names (primary)` %in% plot_labels),
             shape = 1, size = 1.9, color = "black", stroke = 0.8) +
  
  # 4. OVERLAY: Text Labels for 'plot_labels'
  geom_text_repel(data = subset(plot_df, `Gene Names (primary)` %in% plot_labels),
                  aes(label = `Gene Names (primary)`), 
                  size = 4, fontface = "bold", box.padding = 0.5, max.overlaps = Inf) +
  
  #5. Add equation of fitted linear model
  annotate("text", x = 1, y = 3, label = eq_label, 
           hjust = 0, size = 5, fontface = "italic") +
  
  scale_color_manual(values = my_colors) +
  coord_cartesian(xlim = c(-3, 4), ylim = c(-3, 3)) + 
  theme_classic() +
  labs(title = "Regression Residuals", subtitle = "")
```


```{r}
library(dplyr)
library(ggplot2)
library(ggrepel)

# --- 1. SETTINGS ---
STRIP_RATIO <- 8  

# --- 2. PREPARE DATA & CALCULATE GLOBAL LIMITS ---

# 1. Prepare Protein Data (Now aggregated by Protein to ensure single points)
df_prot_c1 <- protein_only_cond1 %>%
  left_join(df.labels %>% select(Entry, `Gene Names (primary)`), by = c("Protein" = "Entry")) %>%
  mutate(Label = coalesce(`Gene Names (primary)`, Protein)) %>%
  # AGGREGATION STEP: Group by Protein/Label and calculate mean
  group_by(Protein, Label) %>%
  summarize(mean_intensity = mean(LogIntensities, na.rm = TRUE), .groups = "drop")

df_prot_c2 <- protein_only_cond2 %>%
  left_join(df.labels %>% select(Entry, `Gene Names (primary)`), by = c("Protein" = "Entry")) %>%
  mutate(Label = coalesce(`Gene Names (primary)`, Protein)) %>%
  # AGGREGATION STEP: Group by Protein/Label and calculate mean
  group_by(Protein, Label) %>%
  summarize(mean_intensity = mean(LogIntensities, na.rm = TRUE), .groups = "drop")

# 2. Global Limits (Proteins)
# (Calculated after aggregation so limits reflect the means, not outliers from single runs)
all_prot_vals <- c(df_prot_c1$mean_intensity, df_prot_c2$mean_intensity)
LIMITS_PROT <- c(min(all_prot_vals, na.rm=T) - 0.5, max(all_prot_vals, na.rm=T) + 0.5)

# 3. RNA Data Prep (Unchanged)
df_rna_c1 <- stats.rna.clean %>%
  filter(Category == paste("Only in", cond1)) %>%
  mutate(mean_intensity = log2(Mean_cond1 + 1), Label = Gene)

df_rna_c2 <- stats.rna.clean %>%
  filter(Category == paste("Only in", cond2)) %>%
  mutate(mean_intensity = log2(Mean_cond2 + 1), Label = Gene)

# Global Limits (RNA)
all_rna_vals <- c(df_rna_c1$mean_intensity, df_rna_c2$mean_intensity)
LIMITS_RNA <- c(min(all_rna_vals, na.rm=T) - 0.1, max(all_rna_vals, na.rm=T) + 0.1)


# --- 3. PLOTTING FUNCTIONS ---

# Vertical Plot (Now used for RNA)
generate_vertical_gutter <- function(data, color_hex, title_text, 
                                     y_limits, 
                                     axis_label = "Log Intensity",
                                     axis_side = "left",    
                                     label_side = "right") 
{
  # Filter for custom labels (plot_labels is defined globally)
  plot_data <- data %>%
    mutate(Rank = min_rank(desc(mean_intensity)),
           label_text = ifelse(Label %in% plot_labels, Label, NA)) 
  
  if (label_side == "right") {
    my_margin  <- margin(0.5, 3.5, 0.5, 1, "cm")
    repel_xlim <- c(0.6, Inf)
  } else {
    my_margin  <- margin(0.5, 1, 0.5, 3.5, "cm")
    repel_xlim <- c(-Inf, -0.6)
  }
  
  p <- ggplot(plot_data, aes(x = 0, y = mean_intensity)) +
    geom_point(color = color_hex, size = 1.5, alpha = 0.8) +
    
    theme_classic(base_size = 20) +
    labs(title = title_text, y = axis_label, x = "") +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = element_text(size = 16, family = "sans"),
      plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
      legend.position = "none",
      panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
      plot.margin = my_margin,
      aspect.ratio = STRIP_RATIO 
    ) +
    
    scale_x_continuous(limits = c(-0.5, 0.5)) +
    scale_y_continuous(limits = y_limits, position = axis_side) +
    coord_cartesian(clip = "off") 
    
    # Overlay & Labels (Only for matches in plot_labels)
    if(sum(!is.na(plot_data$label_text)) > 0) {
      p <- p + 
        geom_point(data = subset(plot_data, !is.na(label_text)), aes(x=0, y=mean_intensity),
                   color = "black", size = 2.0, stroke = 1.0, shape = 1) +
        geom_label_repel(data = subset(plot_data, !is.na(label_text)), aes(label = label_text),
                         xlim = repel_xlim, direction = "y", min.segment.length = 0,
                         force = 0.5, max.overlaps = 10, segment.size = 0.5,
                         point.padding = 0.5, na.rm = TRUE)
    }
    return(p)
}

# Horizontal Plot (Now used for Proteins)
generate_horizontal_gutter <- function(data, color_hex, title_text, 
                                       x_limits, 
                                       axis_label = "Log Intensity",
                                       axis_side = "bottom", 
                                       label_side = "top")    
{
  # Filter for custom labels (plot_labels is defined globally)
  plot_data <- data %>%
    mutate(Rank = min_rank(desc(mean_intensity)),
           label_text = ifelse(Label %in% plot_labels, Label, NA)) 
  
  if (label_side == "top") {
    my_margin  <- margin(2.5, 1, 1, 1, "cm")
    repel_ylim <- c(0.6, Inf)
  } else {
    my_margin  <- margin(1, 1, 2.5, 1, "cm")
    repel_ylim <- c(-Inf, -0.6)
  }
  
  p <- ggplot(plot_data, aes(x = mean_intensity, y = 0)) +
    geom_point(color = color_hex, size = 1.5, alpha = 0.8) +
    
    theme_classic(base_size = 20) +
    labs(title = title_text, x = axis_label, y = "") +
    theme(
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.text.x = element_text(size = 16, family = "sans"),
      plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
      legend.position = "none",
      panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
      plot.margin = my_margin,
      aspect.ratio = 1/STRIP_RATIO 
    ) +
    
    scale_y_continuous(limits = c(-0.2, 0.2)) +
    scale_x_continuous(limits = x_limits, position = axis_side) +
    coord_cartesian(clip = "off") 
    
    # Overlay & Labels (Only for matches in plot_labels)
    if(sum(!is.na(plot_data$label_text)) > 0) {
      p <- p + 
        geom_point(data = subset(plot_data, !is.na(label_text)), aes(x=mean_intensity, y=0),
                   color = "black", size = 2.0, stroke = 1.0, shape = 1) +
        geom_label_repel(data = subset(plot_data, !is.na(label_text)), aes(label = label_text),
                         ylim = repel_ylim, direction = "x", min.segment.length = 0,
                         force = 0.5, max.overlaps = 10, segment.size = 0.5,
                         point.padding = 0.5, na.rm = TRUE)
    }
    return(p)
}


# --- 4. GENERATE PLOTS---

# Protein: DF (Horizontal) 
p_prot_1 <- generate_horizontal_gutter(
  df_prot_c1, c1_color, paste("Protein:", cond1),
  x_limits = LIMITS_PROT, axis_label = "Log Intensity",
  axis_side = "bottom", label_side = "top"
)

# Protein: UF (Horizontal) 
p_prot_2 <- generate_horizontal_gutter(
  df_prot_c2, c2_color, paste("Protein:", cond2),
  x_limits = LIMITS_PROT, axis_label = "Log Intensity",
  axis_side = "top", label_side = "bottom"
)

# RNA: DF (Vertical)
p_rna_1  <- generate_vertical_gutter(
  df_rna_c1, c1_color, paste("RNA:", cond1),
  y_limits = LIMITS_RNA, axis_label = "Log2(CPM + 1)",
  axis_side = "left", label_side = "right"
)

# RNA: UF (Vertical)
p_rna_2  <- generate_vertical_gutter(
  df_rna_c2, c2_color, paste("RNA:", cond2),
  y_limits = LIMITS_RNA, axis_label = "Log2(CPM + 1)",
  axis_side = "right", label_side = "left"
)

# --- 5. DISPLAY ---
print(p_prot_1)
print(p_prot_2)
print(p_rna_1)
print(p_rna_2)
```

Half-life analysis, from Savitski's 2018 Nat. Comm paper (proteome-wide half-life determination for proteins in different primary cells)

Protein half-lives are condensed down to a single value that is the average of determined half-lives across all cell lines where the data quality = "good"
```{r}
# --- HALF LIFE ANALYSIS ---
hl_raw <- read_excel(file.path(ref_dir, "protein-half-life-Savitski-2018_high-qual.xlsx"))

# 1. Clean & Aggregate
hl_agg <- hl_raw %>%
  pivot_longer(cols = -gene_name, names_to = c("cell", "rep", ".value"), 
               names_pattern = "^(.+) replicate (\\d+) (.+)$") %>%
  filter(dataQual == "good") %>%
  group_by(gene_name) %>%
  summarise(mean_half_life = mean(half_life, na.rm = TRUE), .groups="drop")

# 2. Merge (Primary + Secondary Rescue)
df_hl <- proteogenomics_stats %>%
  left_join(hl_agg, by = c("Gene Names (primary)" = "gene_name")) %>%
  rename(hl_primary = mean_half_life)

# Find missing and rescue via synonyms
hl_rescue <- df_hl %>%
  filter(is.na(hl_primary)) %>%
  select(Protein, `Gene Names`) %>%
  separate_rows(`Gene Names`, sep = " ") %>%
  inner_join(hl_agg, by = c("Gene Names" = "gene_name")) %>%
  group_by(Protein) %>%
  summarise(hl_sec = mean(mean_half_life), .groups="drop")

df_final <- df_hl %>%
  left_join(hl_rescue, by="Protein") %>%
  mutate(final_hl = coalesce(hl_primary, hl_sec), log_hl = log10(final_hl)) %>%
  filter(!is.na(final_hl))

# 3. Correlation
cor_res <- cor.test(abs(df_final$Studentized_Resid), df_final$log_hl, method = "spearman")

ggplot(df_final, aes(x = log_hl, y = abs(Studentized_Resid))) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", color = "red") +
  labs(title = "Instability vs Discordance",
       subtitle = paste("Spearman rho:", round(cor_res$estimate, 3), 
                        "| p =", signif(cor_res$p.value, 3))) +
  theme_minimal()
```

Protein half-life calculations and divergence
```{r}
# 1. Define your overflow threshold
overflow_threshold <- 400

# 2. Prepare data: Cap values > threshold at the threshold value
half_life_data_cleaned <- proteogenomics_protein_half_lives %>%
  filter(!is.na(final_half_life)) %>%
  mutate(
    half_life_capped = pmin(final_half_life, overflow_threshold) # Capping logic
  )

# 3. Generate the Histogram
half_life_histo <- ggplot(half_life_data_cleaned, aes(x = half_life_capped)) +
  # Using 'boundary' ensures bins align nicely with 0, 10, 20...
  geom_histogram(binwidth = 10, boundary = 0, fill = "#69b3a2", color = "black", alpha = 0.9) +
  
  # Median line (calculated on ORIGINAL data, not capped data, for accuracy)
  geom_vline(aes(xintercept = median(final_half_life, na.rm = TRUE)),
             linetype = "dashed", color = "red", size = 1) +
  
  # Update axis to show the last tick as "400+"
  scale_x_continuous(
    breaks = seq(0, overflow_threshold, by = 100),
    labels = c(seq(0, overflow_threshold - 100, by = 100), paste0(overflow_threshold, "+"))
  ) +
  
  theme_minimal() +
  labs(
    title = "Distribution of Protein Half-Lives",
    subtitle = paste("Values >", overflow_threshold, "hours are aggregated in the final bin"),
    x = "Half-Life (hours)",
    y = "Number of Proteins"
  )

# Display the plot
print(half_life_histo)
```


UBIQUITYLATION ANALYSIS -> Not the best analysis as of 23 Jan 2026. Takes ubiquitylation data from Choudhary 2024 cell paper and creates binary "TRUE/FALSE" for whether or not the protein is ubiquitinated, comapres between discordant/condordant groups.
```{r}
# --- UBIQUITYLATION ANALYSIS ---
df.ubi <- read_excel(file.path(ref_dir, "Choudhary_ubiquitylation_TableS1.xlsx")) #### only read this once, the readxl() function hates this file.
ubi_ids <- unique(unlist(strsplit(df.ubi$Proteins, ";")))

df_ubi_stat <- df_final %>%
  mutate(
    Ubi_Status = ifelse(Protein %in% ubi_ids, "Ubiquitinated", "No Site"),
    Disc_Dir = case_when(
      Is_Discordant & Studentized_Resid < 0 ~ "Negative",
      Is_Discordant & Studentized_Resid > 0 ~ "Positive",
      TRUE ~ "Concordant"
    )
  )

# Plot: Enrichment in Negative Discordance
df_ubi_stat %>%
  filter(Disc_Dir %in% c("Negative", "Concordant")) %>%
  ggplot(aes(x = Disc_Dir, fill = Ubi_Status)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c("gray80", "darkred")) +
  labs(title = "Ubiquitylation Enrichment", y = "Proportion") +
  theme_classic()

# Stats
fisher.test(table(df_ubi_stat$Disc_Dir[df_ubi_stat$Disc_Dir != "Positive"], 
                  df_ubi_stat$Ubi_Status[df_ubi_stat$Disc_Dir != "Positive"]))
```
